using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MigrationApplication.Models
{
    internal class User
    {
        public int Id { get; set; }
        public string? Name { get; set; }
        public int Age { get; set; }
        public string? Position { get; set; }   // Новое свойство

        /* При изменении модели можно использовать различные варианты:
         * - можем написать sql-скрипт для добавления столбцов или таблиц;
         * - Database.EnsureDeleted для удаления и затем метод Database.EnsureCreated для создания бд
         *   если нам не важны данные;
         * - применить мирграцию. Add-Migration [название_миграции], а после Update-Database.
         * Для использования миграций в Visual Stuido необходимо добавить в проект через менеджер Nuget
         * пакет Microsoft.EntityFrameworkCore.Tools.
         * Database.EnsureCreated() при миграции должен быть закоментирован (в контексте).
         * Кроме основных таблиц (в случае выше таблицы Users) база данных также будет содержать
         * дополнительную таблицу _EFMigrationsHystory, которая будет хранить информацию о миграциях
         * 
         * В некоторых случаях, например, в приложениях с локальной базой данных (SQLite в UWP),
         * мы можем выполнять миграции в процессе выполнения приложения. Для этого определен метод Database.Migrate()
         * db.Database.Migrate();  // миграция
         * 
         * Entity Framework также позволяет создать из файлов миграции скрипт sql, который потом можно запустить 
         * для создания или реорганизации базы данных. Для создания скрипта sql необходимо ввести в окне Package
         * Manager Console команду Script-Migration InitialCreate
         * В результате выполнения этой команды Visual Studio создаст и откроет скрипт sql.
         * 
         * Выше была рассмотрена миграция для контекста данных, который имеет конструктор без параметров и
         * устанавливает настройки подключения в методе OnConfiguring(). 
         * Однако мы можем также передавать параметры подключения в контекст данных извне через конструктор
         * с параметром типа DbContextOptions. Например через appsettings.json.
         * При создании миграции для такого контекста данных мы получим ошибку.
         * Дело в том, что, если единственный конструктор класса контекста принимает параметр DbContext.
         * В этом случае при выполнении миграции инструментарий Entity Frameworkа ищет класс, 
         * который реализует интерфейс IDesignTimeDbContextFactory и который задает конфигурацию контекста
         * Поэтому в этом случае нам необходимо добавить в проект подобный класс ( например SampleContextFactory).
         * В данном случае также получаем конфигурацию из файла appsettings.json и извлекаем из ее строку подключения
         * и таким образом создаем контекст. Хотя этот класс формально нигде не вызывается и никак не используется,
         * фактически он вызывается инфраструктурой Entity Framework при создании миграции.
         */
    }
}
